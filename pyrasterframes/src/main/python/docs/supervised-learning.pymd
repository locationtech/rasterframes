# Supervised Machine Learning

In this example we will demonstrate how to fit and score a supervised learning model with a sample of Sentinel-2 data and hand-drawn vector labels over different [land cover](https://en.wikipedia.org/wiki/Land_cover) types.

```python, setup, echo=False
from IPython.core.display import display
from pyrasterframes.utils import create_rf_spark_session
from pyrasterframes.rasterfunctions import *
from pyspark.sql.functions import lit
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from docs import resource_dir_uri

import os

spark = create_rf_spark_session()
```

## Create and Read Raster Catalog

The first step is to create a Spark DataFrame of our imagery data. To achieve that we will create @ref:[a catalog DataFrame](raster-catalogs.md#creating-a-catalog). In the catalog, each row represents a distinct area and time, and each column is the URI to a band's image product. In this example our catalog just has one row. After reading the catalog, the resulting Spark DataFrame may have many rows per URI, with a column corresponding to each band.

The imagery for feature data will come from [eleven bands of 60 meter resolution Sentinel-2](https://earth.esa.int/web/sentinel/user-guides/sentinel-2-msi/resolutions/spatial) imagery. We also will use the [scene classification (SCL)](https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm) data to identify high quality, non-cloudy pixels.

```python, read_bands, term=True
uri_base = 's3://s22s-test-geotiffs/luray_snp/{}.tif'
bands = ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B09', 'B11', 'B12']
cols = ['SCL'] + bands

catalog_df = pd.DataFrame([
    {b: uri_base.format(b) for b in cols}
])

df = spark.read.raster(catalog=catalog_df,
					   catalog_col_names=cols,
					   tile_dimensions=(128, 128)
					   ).repartition(100)

df = df.select(
    rf_crs(df.B01).alias('crs'),
    rf_extent(df.B01).alias('extent'),
    rf_tile(df.SCL).alias('scl'),
    rf_tile(df.B01).alias('B01'),
    rf_tile(df.B02).alias('B02'),
    rf_tile(df.B03).alias('B03'),
    rf_tile(df.B04).alias('B04'),
    rf_tile(df.B05).alias('B05'),
    rf_tile(df.B06).alias('B06'),
    rf_tile(df.B07).alias('B07'),
    rf_tile(df.B08).alias('B08'),
    rf_tile(df.B09).alias('B09'),
    rf_tile(df.B11).alias('B11'),
    rf_tile(df.B12).alias('B12'),
)
df.printSchema()
```

## Data Prep

### Label Data

The land classification labels are based on a small set of hand drawn polygons in the GeoJSON file [here](https://github.com/locationtech/rasterframes/blob/develop/pyrasterframes/src/test/resources/luray-labels.geojson). The property `id` indicates the type of land cover in each area. For these integer values, 1 is forest, 2 is cropland, and 3 is developed areas.

We will create a very small Spark DataFrame of the label shapes and then join it to the raster DataFrame. Such joins are typically expensive, but in this case both datasets are quite small. To speed up the join for the small vector DataFrame, we put the `broadcast` hint on it, which will tell Spark to put a copy of it on each Spark executor.

After the raster and vector data are joined, we will convert the vector shapes into _tiles_ using the @ref:[`rf_rasterize`](reference.md#rf-rasterize) function. This procedure is sometimes called "burning in" a geometry into a raster. The values in the resulting _tile_ cells are the `id` property of the GeoJSON; which we will use as labels in our supervised learning task. In areas where the geometry does not intersect, the cells will contain a NoData.

```python join_and_rasterize
crses = df.select('crs.crsProj4').distinct().collect()
print('Found ', len(crses), 'distinct CRS.')
crs = crses[0][0]

label_df = spark.read.geojson(os.path.join(resource_dir_uri(), 'luray-labels.geojson')) \
					 .select('id', st_reproject('geometry', lit('EPSG:4326'), lit(crs)).alias('geometry')) \
					 .hint('broadcast')

df_joined = df.join(label_df, st_intersects(st_geometry('extent'), 'geometry'))

df_joined.createOrReplaceTempView('df_joined')
df_labeled = spark.sql("""
SELECT *, rf_rasterize(geometry, st_geometry(extent), id, rf_dimensions(B01).cols, rf_dimensions(B01).rows) AS label
FROM df_joined
""")
```

## Masking Poor Quality Cells

To filter only for good quality pixels, we follow roughly the same procedure as demonstrated in the @ref:[quality masking](nodata-handling.md#masking) section of the chapter on NoData. Instead of actually setting NoData values in the unwanted cells of any of the imagery bands, we will just on filter out the mask cell values later in the process.

```python make_mask
from pyspark.sql.functions import lit

mask_part = df_labeled.withColumn('nodata', rf_local_equal('scl', lit(0))) \
              .withColumn('defect', rf_local_equal('scl', lit(1))) \
              .withColumn('cloud8', rf_local_equal('scl', lit(8))) \
              .withColumn('cloud9', rf_local_equal('scl', lit(9))) \
              .withColumn('cirrus', rf_local_equal('scl', lit(10)))

df_mask_inv = mask_part.withColumn('mask', rf_local_add('nodata', 'defect')) \
                   .withColumn('mask', rf_local_add('mask', 'cloud8')) \
                   .withColumn('mask', rf_local_add('mask', 'cloud9')) \
                   .withColumn('mask', rf_local_add('mask', 'cirrus')) \
                   .drop('nodata', 'defect', 'cloud8', 'cloud9', 'cirrus')
# at this point the mask contains 0 for good cells and 1 for defect, etc
# convert cell type and set value 1 to NoData
df_mask = df_mask_inv.withColumn('mask',
  rf_with_no_data(rf_convert_cell_type('mask', 'uint8'), 1.0)
)

df_mask.printSchema()
```

## Create ML Pipeline

We import various Spark components that we need to construct our [Pipeline](https://spark.apache.org/docs/latest/ml-pipeline.html). These are the objects that will work in sequence to conduct the data preparation and modeling.

```python, imports, echo=True
from pyrasterframes import TileExploder
from pyrasterframes.rf_types import NoDataFilter

from pyspark.ml.feature import VectorAssembler
from pyspark.ml.classification import DecisionTreeClassifier
from pyspark.ml.evaluation import MulticlassClassificationEvaluator
from pyspark.ml import Pipeline
```

SparkML requires that each observation be in its own row, and those observations be packed into a single [`Vector`](https://spark.apache.org/docs/latest/api/python/pyspark.ml.html#module-pyspark.ml.linalg) object. The first step is to "explode" the _tiles_ into a single row per cell or pixel with the `TileExploder` (see also @ref:[`rf_explode_tiles`](reference.md#rf_explode_tiles)). If a _tile_ cell contains a NoData it will become a null value after the exploder stage. Then we filter out any rows that missing or null values, which will cause an error during training. Finally we use the SparkML `VectorAssembler` to create that `Vector`.

It is worth discussing a couple of interesting things about the `NoDataFilter`. First, we filter out missing values in the mask column. Recall above we set undesirable pixels to NoData, so they will be removed at this stage. The other column for the `NoDataFilter` is the `label` column. When it is time to score the model, the pipeline will ignore the fact that there is no `label` column on the input DataFrame.

```python, transformers
exploder = TileExploder()

noDataFilter = NoDataFilter() \
  .setInputCols(['label', 'mask'])

assembler = VectorAssembler() \
  .setInputCols(bands) \
  .setOutputCol("features")
```

We are going to use a decision tree for classification. You can swap out one of the other multi-class classification algorithms if you like. With the algorithm selected we can assemble our modeling pipeline.

```python, pipeline
classifier = DecisionTreeClassifier() \
  .setLabelCol('label') \
  .setFeaturesCol(assembler.getOutputCol())

pipeline = Pipeline() \
  .setStages([exploder, noDataFilter, assembler, classifier])

pipeline.getStages()
```

## Train the Model

Push the "go button"! This will actually run each step of the Pipeline we created including fitting the decision tree model. We filter the DataFrame for only _tiles_ intersecting the label raster, because the label shapes are relatively sparse over the imagery. It would be logically equivalent to either include or exclude this, but it is more efficient to do this filter because it will mean less data going into the pipeline.

```python, train
model = pipeline.fit(df_mask.filter(rf_tile_sum('label') > 0).cache())
```

## Model Evaluation

To view the model's performance, we first call the pipeline's `transform` method on the training dataset. This transformed dataset will have the model's prediction included in each row. We next construct an evaluator and pass it the transformed dataset to easily compute the performance metric. We can also create custom metrics using a variety of DataFrame or SQL transformations.

```python eval
prediction_df = model.transform(df_mask) \
                       .drop(assembler.getOutputCol()).cache()
prediction_df.printSchema()

eval = MulticlassClassificationEvaluator(predictionCol=classifier.getPredictionCol(),
										 labelCol=classifier.getLabelCol(),
										 metricName='accuracy',
)

accuracy = eval.evaluate(prediction_df)
print("\nAccuracy:", accuracy)
```

As an example of using the flexibility provided by DataFrames, the code below computes and displays the confusion matrix. The categories down the rows are the predictions, and the truth labels are across the columns.

```python confusion_mtrx
prediction_df.groupBy(classifier.getPredictionCol()) \
    .pivot(classifier.getLabelCol()) \
    .count() \
	.sort(classifier.getPredictionCol()).show(20, False)
```

## Visualize Prediction

Because the pipeline included a `TileExploder`, we will recreate the tiled data structure. The explosion transformation includes metadata enabling us to recreate the _tiles_. See the @ref:[`rf_assemble_tile`](reference.md#rf-assemble-tile) function documentation for more details. In this case, the pipeline is scoring on all areas, regardless of whether they intersect the label polygons. This is simply done by removing the `label` column, as @ref:[discussed above](supervised-learning.md#create-ml-pipeline).

```python assemble_prediction
scored = model.transform(df_mask.drop('label'))
scored.createOrReplaceTempView('scored')

retiled = spark.sql("""
SELECT extent, crs,
    rf_assemble_tile(column_index, row_index, prediction, 128, 128) as prediction,
    rf_assemble_tile(column_index, row_index, B04, 128, 128) as red,
    rf_assemble_tile(column_index, row_index, B03, 128, 128) as grn,
    rf_assemble_tile(column_index, row_index, B02, 128, 128) as blu
FROM scored
GROUP BY extent, crs
""")

retiled.printSchema()
```

Take a look at a sample of the resulting output and the corresponding area's red-green-blue composite image.

```python display_rgb
sample = retiled.select('prediction', 'red', 'grn', 'blu') \
    .sort(-rf_tile_sum(rf_local_equal('prediction', lit(3.0)))) \
    .first()

sample_prediction = sample['prediction']

red = sample['red'].cells
grn = sample['grn'].cells
blu = sample['blu'].cells
sample_rgb = np.concatenate([red[ :, :, None], grn[:, :, None] , blu[ :, :, None]], axis=2)
mins = np.nanmin(sample_rgb, axis=(0,1))
plt.imshow((sample_rgb -  mins)/ (np.nanmax(sample_rgb, axis=(0,1)) - mins))
```

Recall the label coding: 1 is forest (purple), 2 is cropland (green) and 3 is developed areas(yellow).

```python display_prediction
display(sample_prediction)
```
